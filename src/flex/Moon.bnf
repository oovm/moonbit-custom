{
    parserClass = "com.github.moonbit.parser.MoonParser"
    parserUtilClass = "com.github.moonbit.psi.MoonParserExtension"

    extends = "com.github.moonbit.psi.AnyMoonNode"

    psiClassPrefix = "Moon"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.moonbit.psi"
    psiImplPackage = "com.github.moonbit.psi_node"

    elementTypeHolderClass = "com.github.moonbit.psi.MoonTypes"
    elementTypeClass = "com.github.moonbit.psi.MoonElementType"
    tokenTypeClass = "com.github.moonbit.psi.MoonTokenType"

    psiImplUtilClass = "com.github.moonbit.psi_node.MoonPsiExtension"

    tokens = [
        // comment
        COMMENT_DOCUMENT = "Comment Document"
        COMMENT_LINE = "Comment Line"
        COMMENT_BLOCK = "Comment Block"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
    ]
}

// https://github.com/bytecodealliance/fluent/blob/master/spec/fluent.ebnf
moon ::= statements*
private statements ::= SEMICOLON
    | package
    | define-type
	| declare-struct
	| declare-enum
	| declare-trait
	| declare-impl
	| let-statement
	| declare-function
	| declare-closure
	| declare-test
	| while-statement
	| for-statement
	| if-statement
	| match-statement

// package wasi:blobstore@0.2.0-draft;
package ::= KW_PACKAGE package-name {
	pin = 1
//    mixin = "com.github.bytecodealliance.language.mixin.MixinPackage"
}

package-name ::= module-name (COLON module-name)* package-version?;
package-version ::= AT VERSION;

// =====================================================================================================================
derive-statement ::= KW_DERIVE PARENTHESIS_L (identifier (COMMA identifier)*)? PARENTHESIS_R {
	//	mixin = "com.github.bytecodealliance.language.mixin.MixinDerive"
}
// =====================================================================================================================
declare-struct   ::= modifier* KW_STRUCT identifier declare-generic? struct-body derive-statement? {
	pin = 2
//    mixin = "com.github.bytecodealliance.language.mixin.MixinRecord"
}
struct-body ::= BRACE_L struct-element* BRACE_R
private struct-element ::= COMMA
	| declare-field
	| declare-method
declare-field  ::= KW_MUTABLE? identifier type-hint {
//    mixin = "com.github.bytecodealliance.language.mixin.MixinField"
}
declare-method ::= identifier COLON declare-signature {
//	mixin = "com.github.bytecodealliance.language.mixin.MixinMethod"
}
// =====================================================================================================================
declare-enum ::= modifier* KW_ENUM identifier enum-body derive-statement? {
	pin = 2
}
enum-body ::= BRACE_L enum-element* BRACE_R
private enum-element ::= SEMICOLON
	| declare-variant
	| declare-field
	| declare-method

declare-variant ::= identifier;

// =====================================================================================================================
// priv type UninitializedArray[T] FixedArray[UnsafeMaybeUninit[T]]
define-type ::= modifier* KW_TYPE type-expression type-expression {
	pin = 2
}
type-hint ::= COLON type-expression;
return-type ::= OP_TO type-expression;

generic-call   ::= BRACKET_L (type-expression (COMMA type-expression)* COMMA?)? BRACKET_R;
// resource type-name { method: func() };
declare-trait  ::= modifier* KW_TRAIT identifier trait-body {
	pin = 2
//    mixin = "com.github.bytecodealliance.language.mixin.MixinResource"
}
trait-body ::= BRACE_L trait-element* BRACE_R;
private trait-element ::=
	declare-signature

// pub trait Compare: Eq {
//  compare(Self, Self) -> Int
//}
// to_bool(Self) -> Bool
declare-signature ::= modifier? identifier declare-generic? signature-parameter return-type? {

}
signature-parameter ::= PARENTHESIS_L (identifier (COMMA identifier)* COMMA?)? PARENTHESIS_R

// pub impl Hash for Bool with hash(self) { self.to_int() }
// =====================================================================================================================
declare-impl ::= modifier* KW_IMPLEMENT identifier-free KW_FOR identifier-free return-type? {
	pin = 2
}

// =====================================================================================================================
// world name { }
let-statement ::= modifier? KW_LET KW_MUTABLE? identifier type-hint? OP_ASSIGN term-expression {
	pin = 2
//    mixin = "com.github.bytecodealliance.language.mixin.MixinWorld"
}
// interface name { }
declare-function ::= modifier* KW_FN namepath declare-generic? declare-parameters return-type? (function-body | function-inline) {
	pin = 2
//    mixin = "com.github.bytecodealliance.language.mixin.MixinInterface"
}
function-inline ::= OP_ASSIGN term-expression;

function-body  ::= BRACE_L function-element* BRACE_R {

}
private function-element ::= SEMICOLON
	| let-statement
	| declare-function
	| declare-test
	| while-statement
	| for-statement
	| control-statement
	| term-expression
// (self : Array[T])
declare-parameters ::= PARENTHESIS_L (parameter (COMMA parameter)* COMMA?)? PARENTHESIS_R
parameter ::= identifier COLON type-expression {

}
control-statement ::=
	KW_RETURN term-expression?
	| KW_CONTINUE
	| KW_BREAK term-expression?

modifier ::= KW_PUBLIC | KW_PRIVATE;
declare-generic ::= BRACKET_L (generic-item (COMMA generic-item)*)? BRACKET_R;
generic-item ::= identifier (COLON type-expression)?;
// =====================================================================================================================
declare-closure  ::= KW_FN declare-parameters function-body {
	pin = 1
}
// =====================================================================================================================
declare-test ::= KW_TEST string-literal function-body {
	pin = 1
//	extends = interface
//	mixin = "com.github.bytecodealliance.language.mixin.MixinInterface"
}


// exports: interface
// =====================================================================================================================
if-statement ::= KW_IF then-statement else-statement? {
	pin = 1
}
then-statement ::= term-expression function-body {

}
else-statement ::= KW_ELSE function-body {
	pin = 1
}
match-statement ::= KW_MATCH term-expression match-body {
	pin = 1
}
match-body ::= BRACE_L match-element* BRACE_R;
private match-element ::= match-variant
match-variant ::= identifier;
// =====================================================================================================================
while-statement ::= KW_WHILE term-expression function-body {
	pin = 1
}

for-statement  ::= KW_FOR for-startup for-condition for-increment function-body;
for-startup    ::= term-expression SEMICOLON;
for-condition  ::= term-expression SEMICOLON;
for-increment  ::= term-expression;
// =====================================================================================================================
term-expression ::= term-expression-item (term-infix term-expression-item)*;
term-expression-item ::= term-prefix* term-expression-atom term-suffix*;
term-expression-atom ::= PARENTHESIS_L term-expression PARENTHESIS_R
	| if-statement
	| dict-literal
	| list-literal
	| string-literal
	| string-lines
	| number-literal
	| AT namepath-free
	| namepath
term-prefix ::= OP_ADD | OP_SUB | OP_REF;
term-infix  ::= OP_ASSIGN
	| OP_ADD | OP_ADD_ASSIGN
	| OP_SUB
	| OP_MUL
	| OP_DIV | OP_DIV_ASSIGN
	| OP_MOD
	| OP_EQ | OP_NE
	| OP_LT | OP_LEQ
	| OP_GT | OP_GEQ
	| OP_OR | OP_AND
	| OP_THEN
term-suffix   ::= OP_THROW
	| call-function
	| call-method
	| call-field
	| call-index
	| call-slice
call-function ::= errorable? PARENTHESIS_L (term-expression (COMMA term-expression)* COMMA?)? PARENTHESIS_R;
errorable ::= OP_ERROR | OP_THROW;
call-method   ::= DOT call-function
call-field    ::= DOT identifier
call-index    ::= DOT INTEGER
call-slice    ::= BRACKET_L term-expression (COMMA term-expression)* BRACKET_R;
// =====================================================================================================================
type-expression ::= type-expression-item (type-infix type-expression-item)*;
type-expression-item ::= type-prefix* type-expression-atom type-suffix*;
type-expression-atom ::= PARENTHESIS_L type-expression PARENTHESIS_R
	| identifier
//	| string-literal
//	| number-literal
type-prefix ::= OP_ADD;
type-infix  ::= OP_ADD | OP_TO;
type-suffix ::= generic-call | "?";
// =====================================================================================================================
dict-literal ::= BRACE_L (dict-term (COMMA dict-term)* COMMA?)? BRACE_R
dict-term ::= identifier COLON term-expression;
// =====================================================================================================================
list-literal ::= BRACKET_L (list-term (COMMA list-term)* COMMA?)? BRACKET_R
list-term ::= term-expression;

//   { array: self.array, start: self.start + start, end: self.start + end }
// =====================================================================================================================
string-literal ::= DOUBLE_QUOTE_L STRING_TEXT+ DOUBLE_QUOTE_R;
string-lines   ::= STRING_LINE+
number-literal ::= INTEGER;



private resource-element ::=
    declare-method
  | constructor
  | SEMICOLON
  | HYPHEN
  | DOLLAR
  | ACCENT
  | OP_REF
  | OP_PATTERN_TO




flags       ::= KW_FLAGS identifier BRACE_L (semantic-number (COMMA semantic-number)* COMMA?)? BRACE_R {
	pin = 1
//    mixin = "com.github.bytecodealliance.language.mixin.MixinFlags"
}


variant          ::= KW_VARIANT identifier BRACE_L (variant-item (COMMA variant-item)* COMMA?)? BRACE_R {
	pin = 1
//    mixin = "com.github.bytecodealliance.language.mixin.MixinVariant"
}
variant-item 	 ::= identifier (PARENTHESIS_L type-hint PARENTHESIS_R)? {
//    mixin = "com.github.bytecodealliance.language.mixin.MixinVariantItem"
}


/* Literals */

/* Identifier */
module-name         ::= SYMBOL | ESCAPED;
semantic-number     ::= SYMBOL | ESCAPED;
identifier          ::= SYMBOL | ESCAPED;
identifier-free     ::= SYMBOL | KW_TEST;
namepath            ::= identifier (NAME_JOIN identifier)*
namepath-free       ::= identifier-free (DOT identifier-free)*